using NUnit.Framework;
using DataToScriptableObject;
using DataToScriptableObject.Editor;
using System.Linq;

namespace DataToScriptableObject.Tests.Editor
{
    /// <summary>
    /// Stress tests and edge cases for schema building and type resolution.
    /// Tests the robustness of the system under extreme conditions.
    /// </summary>
    public class SchemaBuilderStressTests
    {
        private GenerationSettings GetDefaultSettings()
        {
            return new GenerationSettings
            {
                SanitizeFieldNames = true,
                NullToken = "null",
                ArrayDelimiter = ";",
                UseListInsteadOfArray = false,
                UseSerializeField = false,
                GenerateCreateAssetMenu = true,
                AddAutoGeneratedHeader = true,
                GenerateTooltips = true,
                ScriptOutputPath = "Assets/Scripts/Generated"
            };
        }

        #region Large Scale Tests

        [Test]
        public void TestSchema_VeryManyColumns()
        {
            // Test with many columns (50+)
            var headers = Enumerable.Range(0, 50).Select(i => $"col{i}").ToArray();
            var types = Enumerable.Range(0, 50).Select(i => i % 4 == 0 ? "int" : i % 4 == 1 ? "float" : i % 4 == 2 ? "bool" : "string").ToArray();
            var values = Enumerable.Range(0, 50).Select(i => $"val{i}").ToArray();
            
            string csv = string.Join(",", headers) + "\n" + 
                        string.Join(",", types) + "\n" +
                        string.Join(",", values);
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(50, schema.Columns.Length);
            // Verify type distribution
            int intCount = schema.Columns.Count(c => c.Type == ResolvedType.Int);
            int floatCount = schema.Columns.Count(c => c.Type == ResolvedType.Float);
            int boolCount = schema.Columns.Count(c => c.Type == ResolvedType.Bool);
            int stringCount = schema.Columns.Count(c => c.Type == ResolvedType.String);
            
            Assert.Greater(intCount, 0);
            Assert.Greater(floatCount, 0);
            Assert.Greater(boolCount, 0);
            Assert.Greater(stringCount, 0);
        }

        [Test]
        public void TestSchema_ManyEnumValues()
        {
            // Test enum with many values (50+)
            var enumValues = Enumerable.Range(0, 50).Select(i => $"Value{i}").ToArray();
            string csv = "id,type\nint,enum\n," + string.Join(",", enumValues) + "\n1,Value5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
            Assert.IsNotNull(schema.Columns[1].EnumValues);
            Assert.AreEqual(50, schema.Columns[1].EnumValues.Length);
        }

        [Test]
        public void TestSchema_DeepArrayNesting()
        {
            // Test arrays with many elements
            var arrayData = string.Join(";", Enumerable.Range(0, 100).Select(i => $"item{i}"));
            string csv = $"id,items\nint,string[]\n1,\"{arrayData}\"";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.StringArray, schema.Columns[1].Type);
        }

        [Test]
        public void TestSchema_ManyRows()
        {
            // Test with many data rows (doesn't directly affect schema but tests parsing)
            var lines = new System.Collections.Generic.List<string> { "id,name\nint,string" };
            for (int i = 0; i < 100; i++)
            {
                lines.Add($"{i},Item{i}");
            }
            string csv = string.Join("\n", lines);
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            Assert.AreEqual(100, rawData.DataRows.Length);
            
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            Assert.AreEqual(2, schema.Columns.Length);
        }

        #endregion

        #region Type Resolution Edge Cases

        [Test]
        public void TestSchema_MixedNumericTypes()
        {
            // Test type inference with mixed numeric data
            string csv = @"value1,value2,value3
1,1.5,1
2,2.0,2.5
3,3.5,3.14159";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // value1 should be int (all integers)
            // value2 should be float (has decimal)
            // value3 should be float (has decimal in last row)
            Assert.AreEqual(ResolvedType.Int, schema.Columns[0].Type);
            Assert.AreEqual(ResolvedType.Float, schema.Columns[1].Type);
            Assert.AreEqual(ResolvedType.Float, schema.Columns[2].Type);
        }

        [Test]
        public void TestSchema_BooleanVariations()
        {
            // Test various boolean representations
            string csv = @"bool1,bool2,bool3,bool4
true,yes,1,TRUE
false,no,0,FALSE";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // bool1 and bool4 should be recognized as bool (true/false)
            // bool2 should be recognized as bool (yes/no)
            // bool3 might be int or bool depending on implementation
            Assert.AreEqual(ResolvedType.Bool, schema.Columns[0].Type);
            Assert.AreEqual(ResolvedType.Bool, schema.Columns[1].Type);
            // bool3 with 1/0 might be int (to avoid confusion with numeric data)
        }

        [Test]
        public void TestSchema_EmptyStringVsNull()
        {
            // Test difference between empty string and null
            string csv = @"text1,text2,text3
"""",null,
value,,";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // All should be string type
            Assert.AreEqual(ResolvedType.String, schema.Columns[0].Type);
            Assert.AreEqual(ResolvedType.String, schema.Columns[1].Type);
            Assert.AreEqual(ResolvedType.String, schema.Columns[2].Type);
        }

        [Test]
        public void TestSchema_NumbersAsStrings()
        {
            // Test numbers in quotes should be treated as strings
            string csv = @"id,code,value
int,string,int
1,""001"",10
2,""002"",20";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.Int, schema.Columns[0].Type);
            Assert.AreEqual(ResolvedType.String, schema.Columns[1].Type);
            Assert.AreEqual(ResolvedType.Int, schema.Columns[2].Type);
        }

        [Test]
        public void TestSchema_ScientificNotation()
        {
            // Test scientific notation numbers
            string csv = @"value
1.5e10
2.3e-5
3.14159";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should be recognized as float/double
            Assert.IsTrue(schema.Columns[0].Type == ResolvedType.Float || 
                         schema.Columns[0].Type == ResolvedType.Double);
        }

        [Test]
        public void TestSchema_NegativeNumbers()
        {
            // Test negative numbers
            string csv = @"int_val,float_val
-10,-15.5
-20,-25.5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.Int, schema.Columns[0].Type);
            Assert.AreEqual(ResolvedType.Float, schema.Columns[1].Type);
        }

        [Test]
        public void TestSchema_LeadingZeros()
        {
            // Test numbers with leading zeros (should be string to preserve)
            string csv = @"id,code
1,001
2,002";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // code column has leading zeros, might be treated as string
            Assert.AreEqual(ResolvedType.Int, schema.Columns[0].Type);
            // Leading zeros often indicate string data (like zip codes)
        }

        #endregion

        #region Attribute Parsing Edge Cases

        [Test]
        public void TestSchema_MultipleAttributesOnSameColumn()
        {
            // Test multiple attributes on one column
            string csv = @"id,value
int,float
key,range(0;100);multiline(3)
1,50.5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.IsTrue(schema.Columns[0].IsKey);
            // value column should have range attribute
            Assert.IsTrue(schema.Columns[1].MinValue.HasValue || schema.Columns[1].MaxValue.HasValue);
        }

        [Test]
        public void TestSchema_MalformedRangeAttribute()
        {
            // Test range with various formats
            string csv = @"val1,val2,val3,val4
float,float,float,float
range(0;100),range(0-100),range(0:100),range(0),
1,2,3,4";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // val1 should parse correctly
            // Others might fail gracefully
            Assert.AreEqual(4, schema.Columns.Length);
        }

        [Test]
        public void TestSchema_RangeWithFloatPrecision()
        {
            // Test range with high precision floats
            string csv = @"value
float
range(0.0001;99.9999)
50.5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            if (schema.Columns[0].MinValue.HasValue)
            {
                Assert.IsTrue(schema.Columns[0].MinValue.Value > 0);
            }
        }

        [Test]
        public void TestSchema_AttributeWithSpecialCharacters()
        {
            // Test attributes with special characters in values
            string csv = @"description
string
tooltip(""Use this item for special effects"")
Some text";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should handle gracefully even if parsing fails
            Assert.AreEqual(1, schema.Columns.Length);
        }

        #endregion

        #region Field Name Edge Cases

        [Test]
        public void TestSchema_AllSpecialCharacterNames()
        {
            // Test field names that are entirely special characters
            string csv = @"@,#,$,%,&
1,2,3,4,5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should generate valid C# identifiers
            Assert.AreEqual(5, schema.Columns.Length);
            foreach (var col in schema.Columns)
            {
                Assert.IsNotEmpty(col.FieldName);
                // Field name should not contain special characters
                Assert.IsFalse(col.FieldName.Contains("@"));
                Assert.IsFalse(col.FieldName.Contains("#"));
                Assert.IsFalse(col.FieldName.Contains("$"));
            }
        }

        [Test]
        public void TestSchema_NumbersAsFieldNames()
        {
            // Test field names that are just numbers
            string csv = @"1,2,3,4
a,b,c,d";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should generate valid C# identifiers (can't start with number)
            Assert.AreEqual(4, schema.Columns.Length);
            foreach (var col in schema.Columns)
            {
                // Should not start with a digit
                Assert.IsFalse(char.IsDigit(col.FieldName[0]));
            }
        }

        [Test]
        public void TestSchema_ReservedKeywordNames()
        {
            // Test C# reserved keywords as field names
            string csv = @"class,public,int,return,void
1,2,3,4,5";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should handle C# keywords (might prefix with underscore or rename)
            Assert.AreEqual(5, schema.Columns.Length);
        }

        [Test]
        public void TestSchema_UnicodeFieldNames()
        {
            // Test Unicode characters in field names
            string csv = @"名前,値,データ
John,100,test";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should either preserve or sanitize Unicode
            Assert.AreEqual(3, schema.Columns.Length);
        }

        [Test]
        public void TestSchema_VeryLongFieldName()
        {
            // Test extremely long field name
            string longName = new string('a', 200);
            string csv = $"{longName}\nvalue";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should handle long names (might truncate)
            Assert.AreEqual(1, schema.Columns.Length);
            Assert.IsNotNull(schema.Columns[0].FieldName);
        }

        [Test]
        public void TestSchema_WhitespaceOnlyFieldName()
        {
            // Test field name that is only whitespace
            string csv = "   ,col2\na,b";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should generate valid identifier
            Assert.AreEqual(2, schema.Columns.Length);
            Assert.IsNotEmpty(schema.Columns[0].FieldName.Trim());
        }

        #endregion

        #region Enum Edge Cases

        [Test]
        public void TestSchema_EnumValuesSimilarToKeywords()
        {
            // Test enum values that are C# keywords
            string csv = @"id,status
int,enum
,null,void,class,public
1,null";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
            Assert.IsNotNull(schema.Columns[1].EnumValues);
        }

        [Test]
        public void TestSchema_EnumWithDuplicateValues()
        {
            // Test enum with duplicate values
            string csv = @"id,type
int,enum
,Fire,Water,Fire,Fire,Earth
1,Fire";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should deduplicate enum values
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
            var uniqueValues = schema.Columns[1].EnumValues.Distinct().ToArray();
            Assert.LessOrEqual(uniqueValues.Length, schema.Columns[1].EnumValues.Length);
        }

        [Test]
        public void TestSchema_EnumWithEmptyValues()
        {
            // Test enum with empty string values
            string csv = @"id,type
int,enum
,Fire,,Water,,Earth
1,Fire";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should filter out empty values
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
            Assert.IsTrue(schema.Columns[1].EnumValues.All(v => !string.IsNullOrEmpty(v)));
        }

        [Test]
        public void TestSchema_EnumWithNumericValues()
        {
            // Test enum with numeric-looking values
            string csv = @"id,priority
int,enum
,1,2,3,4,5
1,3";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should still create enum (even though values look numeric)
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
        }

        [Test]
        public void TestSchema_EnumWithSpecialCharacters()
        {
            // Test enum values with special characters
            string csv = @"id,type
int,enum
,Fire-Damage,Water+Healing,Earth/Stone
1,Fire-Damage";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 3);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.Enum, schema.Columns[1].Type);
            // Enum values should be sanitized for C# identifiers
        }

        #endregion

        #region Directive Processing Edge Cases

        [Test]
        public void TestSchema_DirectiveOverridesInference()
        {
            // Test that class directive overrides default naming
            string csv = @"#class:CustomName
#database:CustomDB
id
1";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual("CustomName", schema.ClassName);
            Assert.AreEqual("CustomDB", schema.DatabaseName);
        }

        [Test]
        public void TestSchema_PartialDirectives()
        {
            // Test with only some directives
            string csv = @"#class:OnlyClass
id
1";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual("OnlyClass", schema.ClassName);
            // Database and namespace should have defaults
            Assert.IsNotNull(schema.DatabaseName);
        }

        [Test]
        public void TestSchema_DuplicateDirectives()
        {
            // Test duplicate directives (last one wins?)
            string csv = @"#class:First
#class:Second
id
1";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should handle duplicate directives gracefully
            Assert.IsNotNull(schema.ClassName);
        }

        [Test]
        public void TestSchema_EmptyDirectiveValues()
        {
            // Test directives with empty values
            string csv = @"#class:
#namespace:
id
1";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 1);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should fall back to defaults
            Assert.IsNotNull(schema.ClassName);
            Assert.IsNotEmpty(schema.ClassName);
        }

        #endregion

        #region Array Type Edge Cases

        [Test]
        public void TestSchema_EmptyArrays()
        {
            // Test empty array values
            string csv = @"id,tags
int,string[]
1,""""
2,";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.StringArray, schema.Columns[1].Type);
        }

        [Test]
        public void TestSchema_ArraysWithDifferentDelimiters()
        {
            // Test arrays when data contains the delimiter character
            string csv = @"id,tags
int,string[]
1,""tag1;tag2;tag3""
2,""tag;with;semicolons""";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            Assert.AreEqual(ResolvedType.StringArray, schema.Columns[1].Type);
        }

        [Test]
        public void TestSchema_MixedTypeArrays()
        {
            // Test what happens when array has mixed types
            string csv = @"id,values
int,string[]
1,""1;2;text;3""";
            
            var rawData = CSVReader.Parse(csv, ",", "#", 2);
            var schema = SchemaBuilder.Build(rawData, GetDefaultSettings());
            
            // Should be string[] to accommodate mixed values
            Assert.AreEqual(ResolvedType.StringArray, schema.Columns[1].Type);
        }

        #endregion
    }
}
